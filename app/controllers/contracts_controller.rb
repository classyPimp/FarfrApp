class ContractsController < ApplicationController
  #!!!!!!!!!!!!!!!###TODO: MOVE TO HELPERS OR TO MODELS LOGIC-CONTAINING SHIT, THIN CONTROLLERS -> FAT MODELS
  #--------------DI-----for helpers
  attr_reader :view_service 
  def initialize(*args)
    @view_service = ViewServices::Contract.new
    super(*args)
  end

  def new
    @contract = Contract.new
    build_contract_associatins_for_nested_forms_for
    template_or_regular?
    contragents_and_approvers_for_select
  end

  def create

    if prepare_params_for_create
      @contract = Contract.new(new_params)
    end
    
    if @contract.save 
      redirect_to @contract, notice: "new contract sussecfully initialized"
    else
      template_or_regular?
      contragents_and_approvers_for_select
      render :new, alert: "some error occured || ADD VALIDATIONS"
    end
  end
 
  def show
    #fetch_approval_info_if_queried
    @contract ||= Contract.includes(:approvers, :users, :contragents, :attachments, {confirmations: [statuses: :user]}).find(params[:id])
    @comment  ||= ContractComment.new
    @view_service.resolve_pending_confirmations(@contract.pending_confirmations)
    contragents_and_approvers_for_select
    ContractApprover.set_contract_visited_on_visit(params[:id], current_user.id)
    respond_to do |f|
      f.html {}
      f.pdf do
        render pdf: "approval page for #{@contract.number}",
               disposition: "attachment"
      end
    end
  end

  def update   
 #REMINDER--sets ContractApprover.approved => time.now for current user if ajaxed with querystring aprove=true
 #this triggers by query string approve=true, remote:true with accepttypejson from contract#show.
    
    run_approve_procedures_if_queried_so and return
    set_signed_by_company_if_queried_so and return 
    set_sent_to_contragent_if_queried_so and return
    set_recieved_from_contragent_if_queried_so and return
    upload_signed_scans_if_queried_so and return
    request_kept_at_confirmation_if_queried_so and return
    
    @contract = Contract.find(params[:id])

    if @contract.update(new_params)
      
      redirect_to :back, notice: "updated"# render json: {status: 'ok'}
      flash[:succes] = "succesfully updated"
    else
      render json: {status: 'error' ,errors: @contract.errors}  
    end 
    
  #END
  end

  def index
    @contracts = contracts_query_for_index
    contragents_and_approvers_for_select
  end


 #+++++++++++++++++++++NON ACTION METHODS
  
  def new_params
    #!!!!!!!!!!!!#TODO delete duplicate values (generated by select hidden optins like id1,_destroy:1)
    #in params e.g. with collect
 ##REMINDER: I decided to not make separate actions for regular contract and template one distinguished like this: for 
 #template- queryparam template=true is sent
  
    unless params[:template]
  
      params.require(:contract).permit(:number, :date, :subject, 
                                       :short_description, {contract_contragents_attributes: [:contragent_id, :_destroy, :id]},
                                       {attachments_attributes: [:document, :_destroy, :is_scan, :is_final, :id, :is_project]}, 
                                       {approvers_attributes: [:user_id, :_destroy, :is_executor, :notified]}, :approval_counter)
      
      
    else
      params[:contract][:number] = "TEMPLATE"
      params.require(:contract).permit(:number, :date, :subject, 
                                       :short_desription, {attachments_attributes: [:document, :_destroy, :is_executor]}, 
                                       {approvers_attributes: [:user_id, :_destroy]})

    end  
  end   
  #END
  def prepare_params_for_create
    #REMINDER this _counter piece is need for Contract.approval_counter, 
    #which is decremented -= 1 every time user approves contract, if approval_counter is 0 contract is approved
    counter = 0
    executor_id = params[:contract][:executor]
    executor_in_list = false
    (params[:contract][:approvers_attributes].each do |a|
      (counter += 1) if a[1][:_destroy] == "false"
      if a[1][:user_id] == executor_id
        executor_in_list = true
      end
      (a[1][:is_executor] = 1) if a[1][:user_id] == executor_id
      (a[1][:notified] = Time.now) if a[1][:user_id] == current_user.id.to_s
    end) or return false
    unless executor_in_list
      params[:contract][:approvers_attributes]['0000000000005'] = {user_id: executor_id, is_executor: 1}
    end
    ((params[:contract][:approval_counter] = counter) > 0) ? nil : (return false)
    true
  end

  #code speaks/ needed for nested form_for contract with it's associations for respected fields 
  #TODO move to helpers
  def contragents_and_approvers_for_select
    (@contragents_for_select = Contragent.select(:name, :id).all.collect do |contragent|
      [contragent.name, contragent.id]
    end) unless defined?(@template)
    @approvers_for_select = User.select(:name, :id).all.collect do |user|
      [user.name, user.id]
    end
  end
  #code speaks/ REMINDER there is regular contract and template contract which differ in form fields (no contragent
  #field for template)/ in views/new if @template is defined special form will be rendered
  def template_or_regular?
  params[:template] ? (@template = true) : false
  end
  #TODO move to contract services
  def build_contract_associatins_for_nested_forms_for 
   @contract.approvers.build
   @contract.attachments.build
   @contract.contract_contragents.build
  end
  #TODO move to Contract model
  #well consider refactoring folowing rail cast on advancesearch 
  def contracts_query_for_index
    unless search = params[:contract_search]
      Contract.all.paginate(page: params[:page], per_page: 10)
    else
      query = "Contract"
      unless search[:number].blank?
        query = query + %Q(.where("contracts.number like ?", "#{search[:number]}"))
      end
      if search[:date_from].blank? && search[:date_to].blank?
      else
        unless search[:date_from].blank?
          query = query + %Q(.where("contracts.date > ?", "#{search[:date_from]}"))
        end
        unless search[:date_to].blank?
          query = query + %Q(.where("contracts.date < ?", "#{search[:date_to]}"))
        end
      end
      unless search[:contragent].blank?
        query = query + %Q(.joins(:contragents).where('contragents.name like ?', "%#{search[:contragent]}%"))
      end
      unless search[:subject].blank?
        query = query + %Q(.where("contracts.subject like ?", "%#{search[:subject]}%"))
      end
      unless search[:description].blank?
        query = query + %Q(.where("contracts.short_description like ?", "%#{search[:description]}%"))
      end
      if search[:unapproved] == "1" && search[:approved] == "1"
        
      else
        if search[:unapproved] == "1" 
          query = query + %Q(.where(contracts: {approved: [nil]}))
        end
        if search[:approved] == "1"
          query = query + %Q(.where("contracts.approved > 0"))
        end
      end
      if search[:template] == "1"
        query = query + %Q(.where(number: "TEMPLATE"))
      end
      unless search[:executor].blank?
        query = query + %Q(.joins(:approvers).where.not(contract_approvers:{is_executor: false}).where(contract_approvers:{user_id: search[:executor]}))
      end
        query = query + %Q(.paginate(page: params[:page], per_page: 20).includes(:contragents, :attachments))
        eval(query)
    end
  end

  # decrements approved counter on Contract, sets approved on contractApprover
  # and sets contract as approved if counter is 0 fo #update
  # runs if params[:approved] == true
  def run_approve_procedures_if_queried_so
    if params[:approve]
      #TODO: Move this part to separate nonaction-method approve_by_user 
      @contract = Contract.includes(:approvers).find(params[:id])
      #approve! returns after save (ContractApprover where user_id is id).approved
      if approved = @contract.approve!(current_user)
        respond_to do |f|
          f.json { render json: {approved: approved}, status: :ok } 
        end   
      else
        render json: {approve: approved}, status: :error
      end 
      return true
    else
      return false
    end
  end

  #sets contract#signed_by_company if params contain set_signed_by_company
  #also this method uses special params method for such
  def set_signed_by_company_if_queried_so
     if params[:set_signed_by_company]
       @contract = Contract.find(params[:id])
       @contract.validation_options = {set_signed_by_company: true}
       if @contract.update(set_signed_by_company_params)
         respond_to do |f|
          #TODO RENDER ONLY %Y_%M_%D AND ALSO IN contr#SHOW same 
           f.json {render json: {status: "ok", response: @contract.signed_by_company}, status: 200}
         end
       else
         respond_to do |f|
           f.json {render json: {status: "error", errors: @contract.errors}, status: 500}
         end
       end
       return true
     else
      return false
     end
  end
  #params for #set_signed_by_company_of queried_so
  def set_signed_by_company_params 
    params.require(:contract).permit(:signed_by_company)     
  end 
  #THE SAME AS for set_signed_by_company_if_queried_so
  def set_sent_to_contragent_if_queried_so
    if params[:set_sent_to_contragent]
      @contract = Contract.find(params[:id])
      @contract.validation_options = {set_sent_to_contragent: true}
      if @contract.update(set_sent_to_contragent_params)
        respond_to do |f|
          f.json {render json: {status: "ok", response: @contract.sent_to_contragent}, status: 200}
         end
      else
        respond_to do |f|
          f.json {render json: {status: "error", errors: @contract.errors}, status: 500}
        end
      end
      return true
    else
      return false
    end
  end
  def set_sent_to_contragent_params
    params.require(:contract).permit(:sent_to_contragent)
  end
  #THE SAME AS FORM set_signed and set_sent
  def set_recieved_from_contragent_if_queried_so
    if params[:set_recieved_from_contragent]
      @contract = Contract.find(params[:id])
      @contract.validation_options = {set_recieved_from_contragent: true}
      if @contract.update(set_recieved_from_contragent_params)
        respond_to do |f|
          f.json {render json: {status: "ok", response: @contract.recieved_from_contragent}, status: 200}
         end
      else
        respond_to do |f|
          f.json {render json: {status: "error", errors: @contract.errors}, status: 500}
        end
      end
      return true
    else
      return false
    end
  end
  def set_recieved_from_contragent_params
    params.require(:contract).permit(:recieved_from_contragent)
  end

  def upload_signed_scans_if_queried_so
    if params[:upload_signed_scans]
      @contract = Contract.find(params[:id])
      if @contract.update(upload_signed_scans_params)
        render json: {status: "ok", response: "uploaded"}, status: 200
      else 
        render json: {status: "error", errors: @contract.errors}, status: 500
      end
      return true
    end
    return false
  end
  def upload_signed_scans_params
    params.require(:contract).permit({attachments_attributes: [:document, :_destroy, :is_scan]})
  end
#-----------REQUEST KEPT AT CONFIRMATION
  def request_kept_at_confirmation_if_queried_so 
    if params[:request_kept_at_confirmation]
      @contract = Contract.select(:id).find(params[:id])
      if request_kept_at_confirmation_params[:contract_kept_at_confirmation_attributes][:initiator] != current_user.id
        @contract.errors.add :base, "BAD ERROR"
      end
      if @contract.update_with_confirmation(request_kept_at_confirmation_params, {type: :kept_at})
        render json: {status: "ok", response: "storage was requested "}, status: 200
      else 
        render json: {status: "error", errors: @contract.errors}, status: 500
      end
      return true
    end
    return false
  end
  def request_kept_at_confirmation_params
    params.require(:contract).permit({contract_kept_at_confirmation_attributes: [:initiator, statuses_attributes: [:user_id]]})
  end

  

  

=begin IN CASE YOU WANT TO AJAX APPROVAL INFO IN INDEX
  def fetch_approval_info_if_queried
   if params[:fetched]
     @contract = Contract.includes(:approvers).find(params[:id])
     respond_to do |f|
       f.js   {render 'approval_info', status: 200}
       f.html {render nothing: true, status: 500}
       f.json {render nothing: true, status: 500}
     end
   else
     false
   end  
  end
=end
end
